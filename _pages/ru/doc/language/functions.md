---
title: Функции
layout: ru/article
permalink: /ru/doc/language/functions/
---

## Простые функции

```
fn functionName (argument1 :type[, argument2 :type, ...]) :returnType {
  // код
}
```

* Для аргументов функции можно не задавать тип, если его можно вывести автоматически.
* Можно не указывать возвращаемый тип функции, если он может быть выведен автоматически.
* Если аргументы функции выводятся автоматически, то это аналогично будет **перегрузке**, т.е. в генерируем коде будет несколько экземляров функции под используемые типы аргументов. Чтобы избежать этого нужно явно определить типы и использовать приведение при вызове функции.
* Приведение типов при вызове функции автоматически не происходит, нужно явно указывать приведение при вызове.
* Типом функции есть следующая конструкция: `function (argType1[,argType2, ...]) returnType`.
* У функций есть метаинформация, которую можно получить с помощью ключевого слова `meta`.
* Для функции можно указать, что она не генерирует исключений с помощью ключевого слова `without-exceptions`: `fn functionName () :returnType without-exceptions {}`. Если компилятор поймет, что избежать исключений не получится, то сгенерируется ошибка.
* Для функций можно задавать атрибуты, которые указываются до сигнатуры.
* Для коротких функций доступен сокращенный синтаксис: `fn functionName (arg: type) -> otherFunction(arg);`.
* Если функция не возвращает значений, то возвращаемый тип у функции будет `void`. Использование этого типа в других ситуациях запрещен.

### Метаинформация функций

Внутри функций возможен доступ к метаинформации, такой как имя, возвращаемый тип и список аргументов.

```
fn foo (argOne :type, argTwo :type) :retType {  
  return value;
}
```

В функции выше метаинформация будет следующей:
```
{
  type: function,
  name: "foo",
  returnType: retType,
  arguments: [{
    name: "arOne",
    type: type
  }, {
    name: "argTwo",
    type: type
  }],
  attributes: []
}
```

Любые модификаторы функции попадают в список атрибутов функции.

Извне доступ к метаинформации можно получить так же с помощью ключевого слова meta:

```
fn foo (argOne :type, argTwo :type) :retType {  
  return value;
}

fn main () {
  let fooName = meta(foo).name;  // "foo".
}
```

Это может быть полезно при использовании callback-аргументов, например для доступа к списку атрибутов.

Если аргументы функции выводятся автоматически, то извне метаинформация будет несколько другой:

```
fn summ (argOne, argTwo) {
  return argOne + argTwo;
}

fn main () {
  console.writeLine(meta(summ).arguments[0].type); // "object". 
}
```

Тип аргумента `object` вызван тем, что без вызова функции не известно какой конкретно тип будет использоваться.

### Тип функции

Вне зависимости от того, как обяъявлена функция, в типе функции будут указываться все параметры, включая типы принимаемых аргументов и возвращаемый тип.

```
fn summ (argOne, argTwo) {
  console.writeLine(meta.returnType);
  return argOne + argTwo;
}

fn main () {
  summ(1, 2); // в консоли появится строка "i32"
  summ(1.0, 2.0); // в консоли появится строка "float32"
}
```

### Автоматический вывод типов в функциях

Функции, в которых тип аргументов и возвращаемого значения выводится автоматически, являются частным случаев шаблонов. Автоматический вывод в функциях основывается на операциях, которые производятся внутри, а так же на основании передаваемых аргументов.

```
fn summ (argOne, argTwo) {
  return argOne + argTwo;
}
```

В случае выше аргументы могут иметь любой числовой тип, либо типы, для которых определен оператор `+`. Возвращаемое значение будет того же типа, что и передаваемые аргументы. При этом аргументы **должны иметь одинаковый тип**. Это очень важно в ситуациях ниже:

```
fn summ (argOne, argTwo) {
  return argOne + argTwo;
}

fn main () {
  let summOne = summ(1, 2); // разрешено, тип аргументов i32 и возвращаемый тип тоже i32
  let summTwo = summ(1, 2.0); // не разрешено, так как типы аргументов разные, поэтому нужно задать явное приведение к какому-то определенному типу
  let summThree = summ(float32(1), 2.0); // разрешено, оба аргумента имеют тип float32, возвращаемое значение так же будет иметь тип float32.
}
```

Если требуется ограничить список типов, возможных к использованию, необходимо воспользоваться шаблонными функциями.

## Чистые функции

```
pure fn functionName (argument :type) :returnType {
  // код
}
```

* Чистые функции работают только с теми переменными или константами, которые передаются через аргументы или объявлены внутри функции.
* Статические переменные внутри чистых функций запрещены.
* На чистые функции распространяются те же правила, что и для обычных функций, если это не противоречит пунктам выше.

## λ-выражения

```
let function = (argument :type) :returnType -> {
  // код
} 
```

* λ-выражения или анонимные функции аналогичны простым функциям, за исключением отсутствия имени.
* λ-выражения имеют тот же лексический контекст, что и блок кода, в котором они объявляются.
* λ-выражения можно определять только внутри функций или методов, задание анонимной функции внутри пространства имен как для переменной запрещено, вместо этого нужно определять обычную функцию.
* λ-выражения должны быть максимально короткими, иначе это самостоятельная единица трансляции.

