---
title: Переменные и константы
layout: ru/article
permalink: /ru/doc/language/variables/
---

* Ключевое слово let позволяет создавать переменные.
* Ключевое слово const позволяет создать константы.
* Для констант и переменных задание типа может быть не обязательным, если тип возможно вывести автоматически.
* Начальное значение для переменных может отсуствовать, но в этом случае указание типа переменной обязательно должно быть.
* При создании переменной всегда она будет инициироваться значением по умолчанию. Для числовых типов это 0, для указателей null, для сложных типов значение по умолчанию либо задается в конструкторе по умолчанию, либо для каждого поля умолчальным значением типа.
* Отменить умолчальную инициализацию можно с помощью модификатора `without-default`: `let variable :type without-default;`. Эта конструкция потенциально не безопасная и ее следует применять тогда, когда значение гарантированно будет задано в этом же блоке кода в дальнейшем.
* Использование переменных или констант, относящихся к экземпляру класса обязательно с ключевым словом this. Это позволяет избежать путаницы с внутренними полями класса, передаваемыми извне аргументами и локальными переменными или константами внутри функций или методов.
* Глобальные переменные в Rail возможны, но желательно их размещать внутри пространств имен. Если глобальная переменная должна располагаться в глобальном пространстве имен, то доступ к ней возможен исключительно с помощью ключевого слова `global` так как это позволит избежать коллизий имен: `let value = global.value`.
* Для переменных можно задавать функции-валидаторы для входных значений. Это позволит сократить дублирование кода и связанные с этими ошибки. Если для какой-либо переменной производить валидацию не нужно, это можно указать с помощью ключевого слова `unsafe`: `variable = value unsafe;`.

В Rail синтаксис создания переменных или констант выглядит следующим образом:

```
let variable :type = initialValue;
const Constant :type = value;
```

Константы ведут себя как read-only значения — значение, которое для них задано при инициализации больше не представляется возможным изменить. Эта особенность полезна при создании констант для экземляров классов:

```
class SomeType {
  public constructor (initialValue :type) {
    this.InstanceConstant = initialValue;
  }
  
  const InstanceConstant :type;
}
```

В примере выше константа задается в конструкторе, после чего ее значение уже нельзя изменить.

Для переменных можно задавать функцию-валидатор, причем это можно делать с различными уровнями доступа. Задание валидатора для базовых типов запрещено. Это вызвано тем, что любые изменения в базовых типах скажутся на работе всего приложения в целом, а это может породить скрытые и трудноопределяемые баги. Например, если в каком-то месте программы задать валидатор для i32, который разрешит значения от 0 до 10, то это распространится на _все_ приложение в целом, сломав возможные счетчики и сделав практически невозможной работу математических выражений.

  * Задание валидации для всех случаев использования переменной.

Этот прием полезен, если для какого-то типа важно обеспечить правильность задания значений в любом месте программы. Задавать валидатор для типа можно следующими способами:

```
class SomeType {
  public let variable with-validator(validatorFunction) :type;
}
```

Глобальные валидаторы рекомендуется задавать непосредственно при объявлении типа. Для _закрытых_ извне полей ввести ограничения можно только таким образом.

  * Валидация переменной в пределах пространства имен.

Существуют ситуации, когда нужно ввести ограничения на переменные в пределах пространств имен. В этом случае синтаксис будет следующим:

```
namespace name {
  SomeType.variable.setValidator(validatorFunction);
}
```

Возможность задать валидатор для уже существующих типов введена для того, чтобы вводить ограничения на _открытые_ поля типов из, например, сторонних бибиотек.

  * Валидация переменной в пределах функции или метода.
  
Валидацию можно ввести для локальной переменной в пределах функции или метода, чтобы гарантировать безопасность ее изменения. Это так же распространяется и на статические переменные. Синтаксис аналогичен заданию валидатора полям классов:

```
static let variable with-validator(validatorFunction) :type;
```

Следует помнить, что валидатор - это функция, которая может исполняться некоторое время и вносить накладные расходы при выполнении программы. Если переменной задается константное значение, то валидация будет происходить на этапе компиляции. Так же, валидация вносит некоторые ограничения:

* Валидацию для не-nullable типов можно использовать только при разрешенных исключениях.
* Валидация для nullable типов может порождать исключения, но это не обязательно, достаточно возвращать null.
